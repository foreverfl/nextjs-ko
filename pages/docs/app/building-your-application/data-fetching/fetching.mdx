---
title: 데이터 가져오기
nav_title: 가져오기
description: Next.js에서 서버 또는 클라이언트에서 데이터를 가져오는 모범 사례를 알아보세요.
---

import Image from "next/image";

# 데이터 가져오기

데이터 가져오기는 모든 애플리케이션의 핵심 부분입니다. 이 페이지에서는 선호하는 방법을 사용하여 데이터를 가져오는 모범 사례를 안내합니다.

## 서버에서 데이터를 가져와야 할까요, 아니면 클라이언트에서 가져와야 할까요?

데이터를 서버에서 가져올지 클라이언트에서 가져올지 결정하는 것은 구축하는 UI 유형에 따라 다릅니다.

대부분의 경우, 실시간 데이터(예: 폴링)가 필요하지 않은 경우 [서버 컴포넌트](/docs/app/building-your-application/rendering/server-components)를 사용하여 서버에서 데이터를 가져올 수 있습니다. 이렇게 하면 몇 가지 이점이 있습니다:

- 단일 서버 라운드 트립으로 데이터를 가져올 수 있어 네트워크 요청 및 클라이언트-서버 순차적 요청 지연을 줄일 수 있습니다.
- 중간 API 경로가 필요한 경우, 액세스 토큰 및 API 키와 같은 민감한 정보가 클라이언트에 노출되는 것을 방지할 수 있습니다.
- 데이터 소스와 가까운 곳에서 데이터를 가져와 지연 시간을 줄일 수 있습니다(애플리케이션 코드와 데이터베이스가 동일한 지역에 있는 경우).
- 데이터 요청을 [캐시](/docs/app/building-your-application/data-fetching/caching-and-revalidating#caching)하고 [재검증](/docs/app/building-your-application/data-fetching/caching-and-revalidating#revalidating-data)할 수 있습니다.

그러나 서버 측 데이터 가져오기는 전체 페이지가 서버에서 다시 렌더링되도록 합니다. UI의 더 작은 부분을 변경/재검증해야 하거나 지속적으로 실시간 데이터를 가져와야 하는 경우(예: 실시간 뷰), 클라이언트 측 데이터 가져오기가 더 적합할 수 있습니다. 이를 통해 클라이언트에서 특정 UI 부분을 다시 렌더링할 수 있습니다.

Next.js에서 데이터를 가져오는 방법은 4가지가 있습니다:

- 서버에서 [`fetch` API](#fetch-api) 사용.
- 서버에서 [ORM 또는 데이터베이스 클라이언트](#orms-and-database-clients) 사용.
- 클라이언트를 통해 서버에서 [Route Handlers](#route-handlers) 사용.
- 클라이언트에서 [데이터 가져오기 라이브러리](#data-fetching-libraries) 사용.

## `fetch` API

Next.js는 네이티브 [`fetch` 웹 API](https://developer.mozilla.org/docs/Web/API/Fetch_API)를 확장하여 서버에서 각 fetch 요청에 대한 [캐싱](/docs/app/building-your-application/data-fetching/caching-and-revalidating#fetch-requests) 및 [재검증](/docs/app/building-your-application/data-fetching/caching-and-revalidating#revalidating-data) 동작을 구성할 수 있도록 합니다. [서버 컴포넌트](/docs/app/building-your-application/rendering/server-components), [Route Handlers](/docs/app/building-your-application/routing/route-handlers), 및 [서버 액션](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)에서 `fetch`를 사용할 수 있습니다. 예를 들어:

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  const data = await fetch("https://api.example.com/...").then((res) =>
    res.json()
  );

  return "...";
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  const data = await fetch("https://api.example.com/...").then((res) =>
    res.json()
  );

  return "...";
}
```

기본적으로 `fetch` 요청은 새로운 데이터를 가져옵니다. 이를 사용하면 전체 경로가 [동적으로 렌더링](/docs/app/building-your-application/rendering/server-components#dynamic-rendering)되고 데이터가 캐시되지 않습니다.

`cache` 옵션을 `force-cache`로 설정하여 `fetch` 요청을 캐시할 수 있습니다. 이는 데이터가 캐시되고 컴포넌트가 [정적으로 렌더링](/docs/app/building-your-application/rendering/server-components#static-rendering-default)됨을 의미합니다:

```js
fetch("https://...", { cache: "force-cache" });
```

또는 [PPR](/docs/app/building-your-application/rendering/partial-prerendering)을 사용하는 경우, `fetch` 요청을 사용하는 컴포넌트를 Suspense 경계로 감싸는 것이 좋습니다. 이렇게 하면 전체 페이지가 아닌 `fetch`를 사용하는 컴포넌트만 동적으로 렌더링되고 스트리밍됩니다:

```tsx filename="@/app/ui/cart.tsx switcher
import { Suspense } from 'react'


export default async function Cart() {
  const res = await fetch('https://api.example.com/...')

  return '...'
}

export default function Navigation() {
  return (
    <>
      <Suspense fallback={<LoadingIcon />}>
        <Cart />
      </Suspense>
    <>
  )
}
```

더 자세한 정보는 [캐싱 및 재검증](/docs/app/building-your-application/data-fetching/caching-and-revalidating) 문서를 참조하세요.

> **알아두면 좋은 점:** Next.js 14 이전 버전에서는 `fetch` 요청이 기본적으로 캐시되었습니다. 자세한 내용은 [업그레이드 가이드](/docs/app/building-your-application/upgrading/version-15)를 참조하세요.

### 요청 메모이제이션

트리의 여러 컴포넌트에서 동일한 데이터를 가져와야 하는 경우, 전역적으로 데이터를 가져와서 props를 아래로 전달할 필요가 없습니다. 대신, 데이터가 필요한 컴포넌트에서 직접 데이터를 가져올 수 있으며, 동일한 데이터에 대해 여러 번 요청하는 것에 대한 성능 문제를 걱정할 필요가 없습니다.

이는 React 렌더링 중에 동일한 URL과 옵션을 가진 `fetch` 요청이 자동으로 메모이제이션되기 때문에 가능합니다.

[요청 메모이제이션](/docs/app/building-your-application/caching#request-memoization)에 대해 자세히 알아보세요.

## ORM 및 데이터베이스 클라이언트

[서버 컴포넌트](/docs/app/building-your-application/rendering/server-components), [Route Handlers](/docs/app/building-your-application/routing/route-handlers), 및 [서버 액션](/docs/app/building-your-application/data-fetching/server-actions-and-mutations)에서 ORM 또는 데이터베이스 클라이언트를 호출할 수 있습니다.

React 렌더링 중에 데이터 요청을 메모이제이션하기 위해 [React `cache`](https://react.dev/reference/react/cache)를 사용할 수 있습니다. 예를 들어, `getItem` 함수가 레이아웃과 페이지 모두에서 호출되더라도 데이터베이스에는 하나의 쿼리만 실행됩니다:

```ts filename="app/utils.ts" switcher
import { cache } from "react";

export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id });
  return item;
});
```

```js filename="app/utils.js" switcher
import { cache } from "react";

export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id });
  return item;
});
```

```tsx filename="app/item/[id]/layout.tsx" switcher
import { getItem } from "@/utils/get-item";

export default async function Layout({
  params: { id },
}: {
  params: { id: string };
}) {
  const item = await getItem(id);
  // ...
}
```

```jsx filename="app/item/[id]/layout.js" switcher
import { getItem } from "@/utils/get-item";

export default async function Layout({ params: { id } }) {
  const item = await getItem(id);
  // ...
}
```

```tsx filename="app/item/[id]/page.tsx" switcher
import { getItem } from "@/utils/get-item";

export default async function Page({
  params: { id },
}: {
  params: { id: string };
}) {
  const item = await getItem(id);
  // ...
}
```

```jsx filename="app/item/[id]/page.js" switcher
import { getItem } from "@/utils/get-item";

export default async function Page({ params: { id } }) {
  const item = await getItem(id);
  // ...
}
```

실험적인 [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)와 [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore) API를 사용하여 이러한 요청의 캐싱 및 재검증 동작을 구성할 수도 있습니다.

## 데이터 가져오기 라이브러리 [#data-fetching-libraries]

[SWR](https://swr.vercel.app/) 또는 [React Query](https://tanstack.com/query/latest)와 같은 데이터 가져오기 라이브러리를 사용하여 클라이언트 컴포넌트에서 데이터를 가져올 수 있습니다. 이러한 라이브러리는 데이터 캐싱, 재검증 및 변경을 위한 자체 API를 제공합니다.

예를 들어, SWR을 사용하여 클라이언트에서 주기적으로 데이터를 가져오는 방법:

```tsx filename="app/page.tsx switcher
"use client"

import useSWR from 'swr'
import fetcher from '@/utils/fetcher'

export default function PollingComponent {
  // 폴링 간격을 2000밀리초로 설정
  const { data } = useSWR('/api/data', fetcher, { refreshInterval: 2000 });

  return '...'
}
```

```js filename="app/page.tsx" switcher
"use client"

import useSWR from 'swr'
import fetcher from '@/utils/fetcher'

export default function PollingComponent {
  // 폴링 간격을 2000밀리초로 설정
  const { data } = useSWR('/api/data', fetcher, { refreshInterval: 2000 });

  return '...'
}
```

## Route Handlers

API 엔드포인트를 생성해야 하는 경우, Next.js는 [Route Handlers](/docs/app/building-your-application/routing/route-handlers)를 지원합니다. Route Handlers는 서버에서 실행되며 민감한 정보(예: API 자격 증명)가 클라이언트에 노출되는 것을 방지합니다.

예를 들어, SWR을 사용하여 Route Handler를 호출하는 방법:

```tsx filename="app/ui/message.tsx" switcher
"use client";

import useSWR from "swr";
import fetcher from "@/utils/fetcher";

export default function Message() {
  const { data } = useSWR("/api/messages", fetcher);

  return "...";
}
```

```jsx filename="app/ui/message.js" switcher
"use client";

import useSWR from "swr";
import fetcher from "@/utils/fetcher";

export default function Message() {
  const { data } = useSWR("/api/messages", fetcher);

  return "...";
}
```

```tsx filename="app/api/messages/route.ts" switcher
export async function GET() {
  const data = await fetch("https://...", {
    headers: {
      "Content-Type": "application/json",
      "API-Key": process.env.DATA_API_KEY,
    },
  }).then((res) => res.json());

  return Response.json({ data });
}
```

```js filename="app/api/messages/route.js" switcher
export async function GET() {
  const data = await fetch("https://...", {
    headers: {
      "Content-Type": "application/json",
      "API-Key": process.env.DATA_API_KEY,
    },
  }).then((res) => res.json());

  return Response.json({ data });
}
```

더 많은 예시는 [Route Handler](/docs/app/building-your-application/routing/route-handlers) 문서를 참조하세요.

> **알아두면 좋은 점**: 서버 컴포넌트는 서버에서 렌더링되므로 서버 컴포넌트에서 Route Handler를 호출할 필요가 없습니다. 데이터에 직접 접근할 수 있습니다.

## 패턴

### 병렬 및 순차적 데이터 가져오기

컴포넌트 내에서 데이터를 가져올 때는 두 가지 데이터 가져오기 패턴을 알아야 합니다: 병렬 및 순차적 패턴입니다.

<Image
  alt="순차적 및 병렬 데이터 가져오기"
  src="https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fsequential-parallel-data-fetching.png&w=1920&q=75"
  width="1600"
  height="525"
/>

- **순차적**: 컴포넌트 트리의 요청들이 서로 의존적입니다. 이는 더 긴 로딩 시간으로 이어질 수 있습니다.
- **병렬**: 경로의 요청들이 즉시 시작되어 동시에 데이터를 로드합니다. 이는 데이터를 로드하는 데 걸리는 총 시간을 줄입니다.

#### 순차적 데이터 가져오기

중첩된 컴포넌트가 있고 각 컴포넌트가 자체 데이터를 가져오는 경우, 이러한 데이터 요청이 [메모이제이션](/docs/app/building-your-application/caching#request-memoization)되지 않으면 데이터 가져오기가 순차적으로 발생합니다.

한 가져오기가 다른 가져오기의 결과에 의존하는 경우와 같이 이 패턴을 원하는 경우가 있을 수 있습니다. 예를 들어, `Playlists` 컴포넌트는 `Artist` 컴포넌트가 데이터 가져오기를 완료한 후에만 데이터 가져오기를 시작합니다. 왜냐하면 `Playlists`가 `artistID` prop에 의존하기 때문입니다:

```tsx filename="app/artist/[username]/page.tsx" switcher
export default async function Page({
  params: { username },
}: {
  params: { username: string };
}) {
  // 아티스트 정보 가져오기
  const artist = await getArtist(username);

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Playlists 컴포넌트가 로딩되는 동안 대체 UI 표시 */}
      <Suspense fallback={<div>로딩 중...</div>}>
        {/* 아티스트 ID를 Playlists 컴포넌트에 전달 */}
        <Playlists artistID={artist.id} />
      </Suspense>
    </>
  );
}

async function Playlists({ artistID }: { artistID: string }) {
  // 아티스트 ID를 사용하여 플레이리스트 가져오기
  const playlists = await getArtistPlaylists(artistID);

  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  );
}
```

```jsx filename="app/artist/[username]/page.js" switcher
export default async function Page({ params: { username } }) {
  // 아티스트 정보 가져오기
  const artist = await getArtist(username);

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Playlists 컴포넌트가 로딩되는 동안 대체 UI 표시 */}
      <Suspense fallback={<div>로딩 중...</div>}>
        {/* 아티스트 ID를 Playlists 컴포넌트에 전달 */}
        <Playlists artistID={artist.id} />
      </Suspense>
    </>
  );
}

async function Playlists({ artistID }) {
  // 아티스트 ID를 사용하여 플레이리스트 가져오기
  const playlists = await getArtistPlaylists(artistID);

  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  );
}
```

(경로 세그먼트의 경우) [`loading.js`](/docs/app/building-your-application/routing/loading-ui-and-streaming) 또는 (중첩된 컴포넌트의 경우) [React `<Suspense>`](/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense)를 사용하여 React가 결과를 스트리밍하는 동안 즉각적인 로딩 상태를 표시할 수 있습니다.

이렇게 하면 전체 경로가 데이터 요청에 의해 차단되는 것을 방지하고, 사용자는 준비된 페이지 부분과 상호 작용할 수 있습니다.

#### 병렬 데이터 가져오기

기본적으로 레이아웃과 페이지 세그먼트는 병렬로 렌더링됩니다. 이는 요청이 병렬로 시작됨을 의미합니다.

그러나 `async`/`await`의 특성 때문에 동일한 세그먼트 또는 컴포넌트 내에서 대기된 요청은 그 아래의 요청을 차단합니다.

병렬로 데이터를 가져오려면 데이터를 사용하는 컴포넌트 외부에서 요청을 정의하여 요청을 적극적으로 시작할 수 있습니다. 이렇게 하면 두 요청을 병렬로 시작하여 시간을 절약할 수 있지만, 두 프로미스가 모두 해결될 때까지 사용자는 렌더링된 결과를 볼 수 없습니다.

아래 예시에서 `getArtist`와 `getAlbums` 함수는 `Page` 컴포넌트 외부에서 정의되고 `Promise.all`을 사용하여 컴포넌트 내부에서 시작됩니다:

```tsx filename="app/artist/[username]/page.tsx" switcher
import Albums from "./albums";

async function getArtist(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}`);
  return res.json();
}

async function getAlbums(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`);
  return res.json();
}

export default async function Page({
  params: { username },
}: {
  params: { username: string };
}) {
  const artistData = getArtist(username);
  const albumsData = getAlbums(username);

  // 두 요청을 병렬로 시작
  const [artist, albums] = await Promise.all([artistData, albumsData]);

  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums} />
    </>
  );
}
```

```jsx filename="app/artist/[username]/page.js" switcher
import Albums from "./albums";

async function getArtist(username) {
  const res = await fetch(`https://api.example.com/artist/${username}`);
  return res.json();
}

async function getAlbums(username) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`);
  return res.json();
}

export default async function Page({ params: { username } }) {
  const artistData = getArtist(username);
  const albumsData = getAlbums(username);

  // 두 요청을 병렬로 시작
  const [artist, albums] = await Promise.all([artistData, albumsData]);

  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums} />
    </>
  );
}
```

또한 [Suspense 경계](/docs/app/building-your-application/routing/loading-ui-and-streaming)를 추가하여 렌더링 작업을 분할하고 결과의 일부를 최대한 빨리 표시할 수 있습니다.

### 데이터 프리로딩

연속된 요청 지연을 방지하는 또 다른 방법은 차단 요청 위에서 적극적으로 호출하는 _프리로드_ 패턴을 사용하는 것입니다. 예를 들어, `checkIsAvailable()`가 `<Item/>`의 렌더링을 차단하므로 그 전에 `preload()`를 호출하여 `<Item/>`의 데이터 의존성을 적극적으로 시작할 수 있습니다. `<Item/>`이 렌더링될 때쯤이면 이미 데이터가 가져와진 상태일 것입니다.

`preload` 함수는 `checkIsAvailable()`의 실행을 차단하지 않습니다.

```tsx filename="components/Item.tsx" switcher
import { getItem } from "@/utils/get-item";

export const preload = (id: string) => {
  // void는 주어진 표현식을 평가하고 undefined를 반환합니다
  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void
  void getItem(id);
};
export default async function Item({ id }: { id: string }) {
  const result = await getItem(id);
  // ...
}
```

```jsx filename="components/Item.js" switcher
import { getItem } from "@/utils/get-item";

export const preload = (id) => {
  // void는 주어진 표현식을 평가하고 undefined를 반환합니다
  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void
  void getItem(id);
};
export default async function Item({ id }) {
  const result = await getItem(id);
  // ...
}
```

```tsx filename="app/item/[id]/page.tsx" switcher
import Item, { preload, checkIsAvailable } from "@/components/Item";

export default async function Page({
  params: { id },
}: {
  params: { id: string };
}) {
  // 아이템 데이터 로딩 시작
  preload(id);
  // 다른 비동기 작업 수행
  const isAvailable = await checkIsAvailable();

  return isAvailable ? <Item id={id} /> : null;
}
```

```jsx filename="app/item/[id]/page.js" switcher
import Item, { preload, checkIsAvailable } from "@/components/Item";

export default async function Page({ params: { id } }) {
  // 아이템 데이터 로딩 시작
  preload(id);
  // 다른 비동기 작업 수행
  const isAvailable = await checkIsAvailable();

  return isAvailable ? <Item id={id} /> : null;
}
```

> **알아두면 좋은 점:** "preload" 함수는 패턴이지 API가 아니므로 어떤 이름으로도 지을 수 있습니다.

#### 프리로드 패턴과 함께 React `cache`와 `server-only` 사용하기

`cache` 함수, `preload` 패턴, 그리고 `server-only` 패키지를 결합하여 앱 전체에서 사용할 수 있는 데이터 가져오기 유틸리티를 만들 수 있습니다.

```ts filename="utils/get-item.ts" switcher
import { cache } from "react";
import "server-only";

export const preload = (id: string) => {
  void getItem(id);
};

export const getItem = cache(async (id: string) => {
  // ...
});
```

```js filename="utils/get-item.js" switcher
import { cache } from "react";
import "server-only";

export const preload = (id) => {
  void getItem(id);
};

export const getItem = cache(async (id) => {
  // ...
});
```

이 접근 방식을 사용하면 데이터를 적극적으로 가져오고, 응답을 캐시하며, 이 데이터 가져오기가 [서버에서만 발생](/docs/app/building-your-application/rendering/composition-patterns#keeping-server-only-code-out-of-the-client-environment)하도록 보장할 수 있습니다.

`utils/get-item` 내보내기는 레이아웃, 페이지 또는 다른 컴포넌트에서 사용하여 아이템 데이터를 언제 가져올지 제어할 수 있습니다.

> **알아두면 좋은 점:**
>
> - 서버 데이터 가져오기 함수가 클라이언트에서 절대 사용되지 않도록 하기 위해 [`server-only` 패키지](/docs/app/building-your-application/rendering/composition-patterns#keeping-server-only-code-out-of-the-client-environment)를 사용하는 것이 좋습니다.

### 민감한 데이터가 클라이언트에 노출되는 것을 방지하기

React의 taint API인 [`taintObjectReference`](https://react.dev/reference/react/experimental_taintObjectReference)와 [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue)를 사용하여 전체 객체 인스턴스나 민감한 값이 클라이언트에 전달되는 것을 방지하는 것을 권장합니다.

애플리케이션에서 tainting을 활성화하려면 Next.js 구성의 `experimental.taint` 옵션을 `true`로 설정하세요:

```js filename="next.config.js"
module.exports = {
  experimental: {
    taint: true,
  },
};
```

그런 다음 taint하려는 객체나 값을 `experimental_taintObjectReference` 또는 `experimental_taintUniqueValue` 함수에 전달하세요:

```ts filename="app/utils.ts" switcher
import { queryDataFromDB } from "./api";
import {
  experimental_taintObjectReference,
  experimental_taintUniqueValue,
} from "react";

export async function getUserData() {
  const data = await queryDataFromDB();
  experimental_taintObjectReference(
    "전체 사용자 객체를 클라이언트에 전달하지 마세요",
    data
  );
  experimental_taintUniqueValue(
    "사용자의 주소를 클라이언트에 전달하지 마세요",
    data,
    data.address
  );
  return data;
}
```

```js filename="app/utils.js" switcher
import { queryDataFromDB } from "./api";
import {
  experimental_taintObjectReference,
  experimental_taintUniqueValue,
} from "react";

export async function getUserData() {
  const data = await queryDataFromDB();
  experimental_taintObjectReference(
    "전체 사용자 객체를 클라이언트에 전달하지 마세요",
    data
  );
  experimental_taintUniqueValue(
    "사용자의 주소를 클라이언트에 전달하지 마세요",
    data,
    data.address
  );
  return data;
}
```

```tsx filename="app/page.tsx" switcher
import { getUserData } from "./data";

export async function Page() {
  const userData = getUserData();
  return (
    <ClientComponent
      user={userData} // taintObjectReference 때문에 오류가 발생합니다
      address={userData.address} // taintUniqueValue 때문에 오류가 발생합니다
    />
  );
}
```

```jsx filename="app/page.js" switcher
import { getUserData } from "./data";

export async function Page() {
  const userData = await getUserData();
  return (
    <ClientComponent
      user={userData} // taintObjectReference 때문에 오류가 발생합니다
      address={userData.address} // taintUniqueValue 때문에 오류가 발생합니다
    />
  );
}
```
